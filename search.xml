<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CentOS8下安装配置VNC Server/VNC Viewer</title>
    <url>/2020/10/15/CentOS8%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEVNC-Server-VNC-Viewer/</url>
    <content><![CDATA[<h2 id="VNC简介"><a href="#VNC简介" class="headerlink" title="VNC简介"></a>VNC简介</h2><p>VNC (Virtual Network Console)，即虚拟网络控制台，它是一款基于 UNIX 和 Linux 操作系统的优秀远程控制工具软件，由著名的 AT&amp;T 的欧洲研究实验室开发，远程控制能力强大，高效实用，并且免费开源。</p>
<a id="more"></a>
<p>VNC基本上是由两部分组成：一部分是客户端的应用程序(VNC Viewer)；另外一部分是服务器端的应用程序(VNC Server)。</p>
<p>在任何安装了客户端的应用程序(VNC Viewer)的计算机都能十分方便地与安装了服务器端的应用程序(VNC Server)的计算机相互连接。</p>
<h2 id="CentOS下VNC-Server安装与配置"><a href="#CentOS下VNC-Server安装与配置" class="headerlink" title="CentOS下VNC Server安装与配置"></a>CentOS下VNC Server安装与配置</h2><p>本人之前已经在服务器上安装了CentOS 8，由于需要进行远程桌面控制，因此首先需要在服务器上安装VNC Server。</p>
<h3 id="VNC-Server安装命令"><a href="#VNC-Server安装命令" class="headerlink" title="VNC Server安装命令"></a>VNC Server安装命令</h3><p><code># yum install tigervnc-server tigervnc-server-module</code></p>
<h3 id="编辑VNC配置"><a href="#编辑VNC配置" class="headerlink" title="编辑VNC配置"></a>编辑VNC配置</h3><p>拷贝一个新的模版配置文件</p>
<p><code># cp /lib/systemd/system/vncserver@.service /etc/systemd/system/vncserver@:1.service</code></p>
<p>打开配置文件</p>
<p><code># vi /etc/systemd/system/vncserver@:1.service</code></p>
<p>将配置文件中的<code>&lt;User&gt;</code>更改为你的用户名，如：root</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;Remote desktop service (VNC)</span><br><span class="line">After&#x3D;syslog.target network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;simple</span><br><span class="line"></span><br><span class="line">ExecStartPre&#x3D;&#x2F;bin&#x2F;sh -c ‘&#x2F;usr&#x2F;bin&#x2F;vncserver -kill %i &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 || :‘</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;vncserver_wrapper &lt;USER&gt; %i</span><br><span class="line"></span><br><span class="line">ExecStop&#x3D;&#x2F;bin&#x2F;sh -c ‘&#x2F;usr&#x2F;bin&#x2F;vncserver -kill %i &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 || :‘</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure>
<h3 id="更新配置文件"><a href="#更新配置文件" class="headerlink" title="更新配置文件"></a>更新配置文件</h3><p><code># systemctl daemon-reload</code></p>
<h3 id="设置VNC-Server密码"><a href="#设置VNC-Server密码" class="headerlink" title="设置VNC Server密码"></a>设置VNC Server密码</h3><p>在第一次启动VNC Server前需要设置密码</p>
<p><code># vncpasswd</code></p>
<p><code>Password:  #新密码</code></p>
<p><code>Verify:  #再次输入</code></p>
<p><code>Would you like to enter a view-only password (y/n)? n</code></p>
<p><code>A view-only password is not used</code></p>
<h3 id="启动服务并设为开机启动"><a href="#启动服务并设为开机启动" class="headerlink" title="启动服务并设为开机启动"></a>启动服务并设为开机启动</h3><p><code># systemctl start vncserver@:1.service</code></p>
<p><code># systemctl enable vncserver@:1.service</code></p>
<h3 id="检查vnc服务正在监听的端口"><a href="#检查vnc服务正在监听的端口" class="headerlink" title="检查vnc服务正在监听的端口"></a>检查vnc服务正在监听的端口</h3><p><code># netstat -tulpn | grep vnc</code></p>
<p><img src="https://raw.githubusercontent.com/FerretDoll/PictureWarehouse/master/img/vnc1.png" width="75%" height="75%"></p>
<h2 id="VNC-Viewer安装与配置"><a href="#VNC-Viewer安装与配置" class="headerlink" title="VNC Viewer安装与配置"></a>VNC Viewer安装与配置</h2><p>在服务器成功安装和配置VNC Server后，还需要在本地安装VNC Viewer进行连接</p>
<h3 id="安装VNC-Viewer"><a href="#安装VNC-Viewer" class="headerlink" title="安装VNC Viewer"></a>安装VNC Viewer</h3><p>先去官网下载<a href="https://www.realvnc.com/en/connect/download/viewer/">VNC Viewer</a></p>
<p><img src="https://raw.githubusercontent.com/FerretDoll/PictureWarehouse/master/img/vnc2.png" width="75%" height="75%"></p>
<p>安装完成如下</p>
<p><img src="https://raw.githubusercontent.com/FerretDoll/PictureWarehouse/master/img/vnc3.png" width="75%" height="75%"></p>
<h3 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h3><p>在VNC Viewer上方输入服务器地址与端口号，然后输入之前设置的VNC Server密码</p>
<p><img src="https://raw.githubusercontent.com/FerretDoll/PictureWarehouse/master/img/vnc4.png" width="75%" height="75%"></p>
<p>连接成功后便会显示远程服务器</p>
<p><img src="https://raw.githubusercontent.com/FerretDoll/PictureWarehouse/master/img/vnc5.png" width="75%" height="75%"></p>
<p>默认的图像质量为低，可以在设置中调整图像质量</p>
<p><img src="https://raw.githubusercontent.com/FerretDoll/PictureWarehouse/master/img/vnc6.png" width="75%" height="75%"></p>
<p>大功告成！现在可以愉快地远程操作服务器了</p>
]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>远程控制</tag>
      </tags>
  </entry>
  <entry>
    <title>文献笔记(1)--G-ALIGNER：几何问题中的图形理解</title>
    <url>/2021/07/22/literature_note_1/</url>
    <content><![CDATA[<blockquote>
<p>题名：<strong>Diagram Understanding in Geometry Questions</strong><br>作者：Min Joon Seo, Hannaneh Hajishirzi, Ali Farhadi, Oren Etzioni<br>时间：2014<br>来源：Proceedings of the National Conference on Artificial Intelligence</p>
</blockquote>
<h2 id="文献总结"><a href="#文献总结" class="headerlink" title="文献总结"></a>文献总结</h2><p>这篇文献提出了一种专用与文本+图表的图形理解方法G-ALIGNER，该方法可以识别几何图形中的视觉元素，同时最大限度地提高文本和视觉数据之间的一致性。本研究引入了一个次模优化方程和一个准确的贪心近似过程来识别图表中的视觉元素并将它们与文本对齐。</p>
<a id="more"></a>
<p>该研究存在一些不足：需要手动注释来识别图中的符号，并且无法处理特殊的关系符号，如等腰线、平行和垂直等；解题过程采用一种按比例缩放的方法，先根据检测到的图元像素长度和对应文本描述的长度，计算题中的单位长度与像素长度的比例，然后根据检测到的目标图元的像素长度按比例缩放后得到最终答案，因此需要精准测量的图表。</p>
<center>
    <img height="75%" width="75%" src="https://raw.githubusercontent.com/FerretDoll/PictureWarehouse/master/img/note1_1.png">
    <br>
    <div style="color:orange; display: inline-block; color: #999; padding: 2px;">图形理解：识别图表中的视觉元素并将它们与相应文本对齐</div>
</center>

<h2 id="研究背景"><a href="#研究背景" class="headerlink" title="研究背景"></a>研究背景</h2><p>自动解决几何问题是一个存在很久的人工智能问题。本文专注于研究文本附加图表的几何图形理解问题，这也是在研究更复杂的图形理解问题前需要完成的工作。</p>
<p>几何问题通常包括文本描述和对应的图表。解决几何问题的第一步是理解图形，它包括发现（discover）图表中的视觉元素、它们的位置、它们的几何特性，并将这些视觉元素与相应的文本描述对齐。</p>
<p>此前的图形理解方面的一些研究工作，分别研究了文本分析和图形理解的问题。现有的算法能够从图片中鉴别出独立的基本形状（例如圆、矩形和三角形等），但无法鉴别图表中的其他复杂形状，并且没有试着用本文中的方法来发现（discover）这些形状。此外，很少有人通过使用相应的文本来识别图表中的形状。</p>
<h2 id="研究目的"><a href="#研究目的" class="headerlink" title="研究目的"></a>研究目的</h2><p>设计一种用于几何问题（文本+图表）图形理解的新方法G-ALIGNER，该方法可以发现并识别各种形状，包括线、圆、多边形和其他由视觉图元组成的形状，并将它们与相应的文本对齐。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="图元（Primitive）"><a href="#图元（Primitive）" class="headerlink" title="图元（Primitive）"></a>图元（Primitive）</h3><p>图元是从图中提取的线段或圆弧。从图表图像中提取的所有图元的集合可表示为$L=\left \{L_{1},L_{2},…,L_{n}\right \}$。</p>
<h3 id="视觉元素（Visual-Element）"><a href="#视觉元素（Visual-Element）" class="headerlink" title="视觉元素（Visual Element）"></a>视觉元素（Visual Element）</h3><p>视觉元素是具有特定属性的图元的组合。例如，三角形是一种视觉元素，由三条以特定方式连接的线段组成。所有视觉元素的词汇及其相应的几何属性都用$V$表示。$V$中的图元包括：线段、弦、直径、割线、切线、半径、圆、圆弧、点、交点、三角形、矩形、梯形、方形、高度和底等。</p>
<h3 id="文本提及（Textual-Mention）"><a href="#文本提及（Textual-Mention）" class="headerlink" title="文本提及（Textual Mention）"></a>文本提及（Textual Mention）</h3><p>文本提及是与视觉元素相对应的单词或短语。例如，圆这个词是视觉元素圆的文字提及。从问题中提取的所有文本提及的集合可表示为$T=\left \{T_{1},T_{2},…,T_{m}\right \}$</p>
<h2 id="研究问题"><a href="#研究问题" class="headerlink" title="研究问题"></a>研究问题</h2><p>研究如何优化图元的识别和对齐。</p>
<ul>
<li>研究如何尽可能从几何问题中可用的文本和视觉信息的耦合中受益，这个问题可以转化为从图中提取的所有初始图元$L$中搜索最佳子集$\hat{L}$。一个理想的子集$\hat{L}$应该包含以下图元：1）解释图中所有重要的像素；2）在视觉上是连贯的；3) 形成能与问题中的相应文本很好地对齐的视觉元素。</li>
<li>研究如何初始化图表中初始图元$L$。</li>
<li>将寻找最佳子集$\hat{L}$的问题定义为优化问题，设计需要优化的目标函数。</li>
<li>证明目标函数属于<a href="https://baike.baidu.com/item/次模函数/15445501?fr=aladdin">次模函数</a>，这意味着存在一种贪心方法可以准确逼近最优解。</li>
</ul>
<h2 id="研究方法"><a href="#研究方法" class="headerlink" title="研究方法"></a>研究方法</h2><p>首先对可能的图元集合进行初始化，然后迭代添加可以带来最大化增益的图元。</p>
<center>
    <img src="https://raw.githubusercontent.com/FerretDoll/PictureWarehouse/master/img/note1_2.png">
    <br>
    <div style="color:orange; display: inline-block; color: #999; padding: 2px;">G-ALIGNER：耦合图元识别和对齐的方法</div>
</center>

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul>
<li>图元初始化: 为了去除噪声，研究者首先在原始图像上使用了<strong>弱高斯模糊</strong>，之后对图片进行<strong>二值化</strong>处理。然后，使用<a href="https://zhuanlan.zhihu.com/p/47649796">霍夫变换</a>（Hough Transform）为给定的图表提取图元（线段和圆弧）。由于霍夫变换的结果没有关于直线或圆弧的起点和终点的信息，只有图元的参数表示是已知的。因此，需要进行<strong>后处理</strong>以确定图元的端点。研究者检测并连接位于同一条直线或圆弧上的连续二进制点。对于每个感兴趣的基元，将产生独立的线段，其中存储了线段的开始和结束。此外，由于实验评估表明，没有一组参数可以很好地处理大量的样本，因此研究者将阈值设置为一个较低的数字，以过度生成大量的图元，这样就有更大概率从过度生成的图元集中找到正确的图元集。最后，使用迭代优化，从一个图元$L$的大型噪声估计池中选择正确的子集$\hat{L}$。</li>
<li>角点初始化：为了加强视觉元素的连贯性，需要尽可能让一组选定的图元在视觉上连贯。研究者使用图表中的角点作为粘合函数。与远离角点的两个图元相比，两个共享端点靠近角点的图元要更好。研究者使用<a href="https://www.jianshu.com/p/133ee1dde482">哈里斯角点检测器</a>（Harris Corner Detectors）来识别可能的角点位置。根据角点与图元的接近程度对角点进行评分。</li>
<li>提及初始化：研究者使用$V$中的视觉元素列表，通过<strong>关键字搜索</strong>从文本描述中提取文本提及。</li>
</ul>
<h3 id="迭代优化"><a href="#迭代优化" class="headerlink" title="迭代优化"></a>迭代优化</h3><p>为了从初始图元集$L$中找出最佳的子集$\hat{L}$，本文提出了一个集函数</p>
<script type="math/tex; mode=display">\mathcal{F}(\hat{L},D,T)=\mathcal{P}(D,\hat{L})+\mathcal{C}(C,\hat{L})+\mathcal{S}(T,\hat{L}) \tag{1}</script><p>，用于评估子集$\hat{L}$的质量，最佳子集$\hat{L}$就是最大化集函数$\mathcal{F}$的子集。该集函数包含以下三个组成部分：1）$\mathcal{P}$用来确保理想的子集$\hat{L}$具有良好的图表图像覆盖率，也就是说，图$D$中的大多数非白色像素能被$\hat{L}$解释；2）$\mathcal{C}$用来鼓励选择能形成更大且连贯的视觉元素的$\hat{L}$，这可以通过图元之间的视觉一致性来编码，即$\hat{L}$中已识别图元与实际角点$C$之间的距离；3）$\mathcal{S}$用于对问题中的文本提及$T$与从图中发现的视觉元素之间的对齐进行建模。通过上述描述可以发现，寻找子集$\hat{L}$的过程就是对目标函数$\mathcal{F}$的<a href="https://baike.baidu.com/item/组合优化算法/20837241?fr=aladdin">组合优化</a>过程。</p>
<p>通过减少加权集覆盖问题来优化$\mathcal{F}$是NP-hard的。然而，该文章证明了目标函数$\mathcal{F}$是次模函数，这意味着存在一种贪心方法可以准确逼近最优解。</p>
<p>在迭代优化开始前，先将最优图元集初始化为空集$\hat{L}=\varnothing$。然后重复下面的步骤。在第$k+1$次迭代时，选择使以下方程最大化的图元$l$，假设$L^{k}$是第$k$次迭代的最佳子集。</p>
<script type="math/tex; mode=display">\hat{L}^{k+1}={\rm arg} \max_{l\in L\backslash \hat{L}^{k}}\mathcal{F}(\hat{L}^{k}\cup l)-\mathcal{F}(\hat{L}^{k}) \tag{2}</script><p>以下图片显示了这种贪心方法的步骤。首先在开始时过度生成图元，并在每次迭代时添加一个图元，该图元可以使方程$(2)$最大化。红色线段对应于每次迭代添加的图元，蓝色十字对应于检测到的角点。</p>
<center>
    <img height="75%" width="75%" src="https://raw.githubusercontent.com/FerretDoll/PictureWarehouse/master/img/note1_3.png">
    <br>
    <div style="color:orange; display: inline-block; color: #999; padding: 2px;">使用贪心方法迭代添加图元的步骤</div>
</center>

<h2 id="实验评估"><a href="#实验评估" class="headerlink" title="实验评估"></a>实验评估</h2><h3 id="实验设置"><a href="#实验设置" class="headerlink" title="实验设置"></a>实验设置</h3><p>该研究构建了一个高中平面几何问题的数据集，其中每个问题都有英文文本描述并附有图表。出于评估目的，研究者使用正确的视觉元素以及文本提及和视觉元素之间的对齐来注释图表。通过手动注释图中的所有图元来收集真实标签。该数据集由100个问题和482个基本事实对齐组成</p>
<p>G-ALIGNER方法的评估分为两个部分：</p>
<ul>
<li><strong>识别图表中的图元</strong>。将G-ALIGNER检测到的图元与数据集图片的真实图元进行比较，并计算重叠量。如果重叠量大于阈值$α$，则认为是正确的预测。精度定义为正确识别图元的数量除以识别图元的总数。召回率是正确识别的图元数除以真实的图元数。</li>
<li><strong>将视觉元素与文本提及对齐</strong>。评估G-ALIGNER是否正确地将文本提及与视觉元素对齐。</li>
</ul>
<h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><h4 id="图元识别"><a href="#图元识别" class="headerlink" title="图元识别"></a>图元识别</h4><p>研究者将G-ALIGNER方法与使用霍夫变换来识别图元的基线进行比较。下图显示了不同重叠率下的F1分数。G-ALIGNER显着优于基线，因为（1）G-ALIGNER耦合了视觉和文本元素（2）G-ALIGNER加强了图表的一致性（3）G-ALIGNER 不需要参数调整。基线在大部分情况下保持相对较高的召回率，但精度较低。例如，在$α=0.8$时，基线在86%的召回率下达到69%的精度，而G-ALIGNER在93%的召回率下达到95%的精度。</p>
<center>
    <img height="90%" width="90%" src="https://raw.githubusercontent.com/FerretDoll/PictureWarehouse/master/img/note1_4.png">
    <br>
    <div style="color:orange; display: inline-block; color: #999; padding: 2px;">G-ALIGNER和基线的图元识别表现比较</div>
</center>

<p>下图展示了500个参数样本的基线F1分数分布。该图还显示了“最佳基线”（手动调整参数）和G-ALIGNER的位置。比较清楚地展示了G-ALIGNER如何在任何参数组合下优于基线。</p>
<center>
    <img height="75%" width="75%" src="https://raw.githubusercontent.com/FerretDoll/PictureWarehouse/master/img/note1_5.png">
    <br>
    <div style="color:orange; display: inline-block; color: #999; padding: 2px;">通过随机选择的参数获得的基线F1分数的归一化直方图</div>
</center>

<h4 id="消融实验"><a href="#消融实验" class="headerlink" title="消融实验"></a>消融实验</h4><p>研究G-ALIGNER的目标方程$\mathcal{F}$中每个组件的重要性。研究者分别从目标方程中去除了$\mathcal{S}$、$\mathcal{C}$、$\mathcal{S}+\mathcal{C}$。结果显示，删除这两个组件会降低精度和召回率。去除$\mathcal{S}$带来的影响大于$\mathcal{C}$，这体现了耦合文本和视觉数据的重要性。</p>
<center>
    <img height="75%" width="75%" src="https://raw.githubusercontent.com/FerretDoll/PictureWarehouse/master/img/note1_6.png">
    <br>
    <div style="color:orange; display: inline-block; color: #999; padding: 2px;">针对图元识别的消融实验</div>
</center>

<h4 id="对齐文本提及和视觉元素"><a href="#对齐文本提及和视觉元素" class="headerlink" title="对齐文本提及和视觉元素"></a>对齐文本提及和视觉元素</h4><p>为了研究G-ALIGNER在对齐文本提及和视觉元素方面的性能，研究者将实验的对齐结果与基线对齐进行比较。G-ALIGNER达到90%的准确率，基线在重叠率$α=0.8$时达到64%的准确率。这证实了将文本和视觉信息结合起来可以提供更好的对齐效果。</p>
<h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>G-ALIGNER方法在实验中显示出不错的结果。但是在某些情况下，该模型无法识别图表元素。如果问题的文本没有提到任何图表元素，那么该模型相对于标准基线的提升是微不足道的。此外，该方法无法识别词汇表之外的视觉元素，并且如果一个视觉元素的比例超出范围，就会导致识别失败。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>本研究的最终目标是建立一个可以解决几何问题的自动化系统，实现这一目标的第一步是构建一种图形理解方法。然而此前的研究没有实现一种不需要参数调整和特定问题启发式的统一框架。本研究提出了G-ALIGNER，它通过将图元检测并与文本耦合来理解图表。G-ALIGNER允许我们通过缩放方法使用按比例绘制的图表解决几何问题，并且可以枚举所有可能的视觉元素、它们的几何属性及其几何关系。</p>
]]></content>
      <categories>
        <category>文献笔记</category>
      </categories>
      <tags>
        <tag>图形理解</tag>
        <tag>平面几何</tag>
      </tags>
  </entry>
  <entry>
    <title>Apriori算法详解</title>
    <url>/2020/10/15/apriori/</url>
    <content><![CDATA[<h2 id="Apriori算法简介"><a href="#Apriori算法简介" class="headerlink" title="Apriori算法简介"></a>Apriori算法简介</h2><p>Apriori算法是一种常用的用于挖掘出数据<strong>关联规则（Association Rules）</strong>的算法，“apriori”在拉丁语中翻译为“来自以前”，顾名思义，这个算法是使用先验知识来预测数据的关联规则。</p>
<a id="more"></a>
<p>说到关联规则，我们不得不提到一个经典案例——啤酒与尿布。在这个案例中，沃尔玛发现看似两个无关的商品，它们却经常被一起购买，这是为什么呢？在美国有婴儿的家庭中，一般是母亲在家中照看婴儿，年轻的父亲前去超市购买尿布，父亲在购买尿布的同时，往往会顺便为自己购买啤酒，这样就会出现啤酒与尿布这两件看上去不相干的商品经常会出现在同一个购物篮的现象。这两种看似不相干的商品之间显现出强相关性，于是商家可以将啤酒货架放在尿布货架旁边以增加收益。</p>
<p>这个案例中研究啤酒与尿布的关系的方法就叫做“购物篮分析”，本质上就是挖掘数据关联规则，而Apriori算法就是最经典的关联规则挖掘算法。</p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="支持度（Support）"><a href="#支持度（Support）" class="headerlink" title="支持度（Support）"></a>支持度（Support）</h3><p>数据集中包含该项集的数据所占数据集的比例，度量一个集合在原始数据中出现的频率。关联规则A-&gt;B的支持度$support=P(AB)$，指的是事件A和事件B同时发生的概率（相当于联合概率）。</p>
<p>通常我们需要事先设置一个支持度的阈值来对项集进行筛选。</p>
<h3 id="置信度（Confidence）"><a href="#置信度（Confidence）" class="headerlink" title="置信度（Confidence）"></a>置信度（Confidence）</h3><p>置信度$confidence=P(B|A)=\frac{P(AB)}{P(A)}$,指的是发生事件A的基础上发生事件B的概率（相当于条件概率）。</p>
<h3 id="频繁k项集（Frequent-k-Itemset）"><a href="#频繁k项集（Frequent-k-Itemset）" class="headerlink" title="频繁k项集（Frequent k Itemset）"></a>频繁k项集（Frequent k Itemset）</h3><p>项集就是项的集合，比如牛奶和面包组成一个集合{牛奶，面包}，那么牛奶和面包就是项，而{牛奶，面包}为一个二项集。频繁项集表示的就是在数据集中频繁出现的项集。如果事件A中包含k个元素，那么称这个事件A为k项集，并且事件A满足最小支持度阈值的事件称为频繁k项集。</p>
<h2 id="Apriori算法原理"><a href="#Apriori算法原理" class="headerlink" title="Apriori算法原理"></a>Apriori算法原理</h2><h3 id="Apriori算法性质"><a href="#Apriori算法性质" class="headerlink" title="Apriori算法性质"></a>Apriori算法性质</h3><ol>
<li>如果某个项集是频繁的，那么它的所有子集也是频繁的；</li>
<li>如果某个项集是非频繁的，那么它的所有超集也是非频繁的；</li>
<li>如果频繁k项集集合中包含单个项目i的个数小于k-1,则i不可能在频繁k项集中；</li>
<li>基于此，Apriori算法从单元素项集开始，通过组合满足最小支持度的项集来形成更大的集合。</li>
</ol>
<p>其实Apriori算法就是通过排除法来选择频繁项集和关联规则，算法的目标是找到最大的频繁k项集。</p>
<h3 id="Apriori算法过程"><a href="#Apriori算法过程" class="headerlink" title="Apriori算法过程"></a>Apriori算法过程</h3><p>Apriori算法过程分为两个步骤：</p>
<ol>
<li>通过迭代，检索出事务数据库中的所有频繁项集，即支持度不低于用户设定的阈值的项集；</li>
<li>利用频繁项集构造出满足用户最小置信度的关联规则。</li>
</ol>
<p>具体过程就是：</p>
<ol>
<li>先搜索出候选1项集并计算对应的支持度，通过筛选去掉支持度低于阈值的候选1项集，得到频繁1项集；</li>
<li>通过连接频繁1项集得到候选2项集并计算对应的支持度，通过筛选去掉支持度低于阈值的候选2项集，得到频繁2项集；</li>
<li>以此类推，不断循环，直到无法发现频繁k+1项集为止，此时的频繁k项集便是算法的输出结果。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FerretDoll/PictureWarehouse/master/img/apriori1.png" alt="Apriori算法步骤" width="75%" height="75%"></p>
<h3 id="由频繁项集产生强关联规则"><a href="#由频繁项集产生强关联规则" class="headerlink" title="由频繁项集产生强关联规则"></a>由频繁项集产生强关联规则</h3><p>在找到所有频繁项集后，我们还需要根据频繁项集生成关联规则：</p>
<ol>
<li>对于每个频繁项集L，生成其所有的非空子集；</li>
<li>对与L的每个非空子集x，计算其置信度confidence(x)，若confidence(x)大于等于最小置信度，则强规则x-&gt;(L-x)成立。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/FerretDoll/PictureWarehouse/master/img/apriori2.png" width="75%" height="75%"></p>
<h2 id="R语言中实现Apriori算法"><a href="#R语言中实现Apriori算法" class="headerlink" title="R语言中实现Apriori算法"></a>R语言中实现Apriori算法</h2><p>R语言中的Apriori算法实现包含在arules包中。</p>
<h3 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h3><p>利用arules包中自带的Groceries数据集，该数据集是来自一个现实世界中的超市经营一个月的购物数据，包含了9835次交易。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">library</span>(arules)</span><br><span class="line">&gt; data(Groceries)</span><br><span class="line">&gt; Groceries</span><br><span class="line">transactions <span class="keyword">in</span> sparse format with</span><br><span class="line"> <span class="number">9835</span> transactions (rows) and</span><br><span class="line"> <span class="number">169</span> items (columns)</span><br></pre></td></tr></table></figure>
<h3 id="探索性数据分析"><a href="#探索性数据分析" class="headerlink" title="探索性数据分析"></a>探索性数据分析</h3><p>通过inspect()函数可以看到超市的交易记录。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; inspect(Groceries[<span class="number">1</span>:<span class="number">5</span>])</span><br><span class="line">    items                     </span><br><span class="line">[<span class="number">1</span>] &#123;citrus fruit, semi-finished bread, margarine, ready soups&#125;             </span><br><span class="line">[<span class="number">2</span>] &#123;tropical fruit, yogurt,                  </span><br><span class="line">     coffee&#125;                  </span><br><span class="line">[<span class="number">3</span>] &#123;whole milk&#125;              </span><br><span class="line">[<span class="number">4</span>] &#123;pip fruit, yogurt, cream cheese, meat spreads&#125;            </span><br><span class="line">[<span class="number">5</span>] &#123;other vegetables, whole milk, condensed milk, long life bakery product&#125;</span><br></pre></td></tr></table></figure>
<p>通过summary()函数可以查看该数据集的一些基本信息。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; summary(Groceries)</span><br><span class="line">transactions as itemMatrix <span class="keyword">in</span> sparse format with</span><br><span class="line"> <span class="number">9835</span> rows (elements/itemsets/transactions) and</span><br><span class="line"> <span class="number">169</span> columns (items) and a density of <span class="number">0.02609146</span> </span><br><span class="line"></span><br><span class="line">most frequent items:</span><br><span class="line">      whole milk other vegetables       rolls/buns             soda </span><br><span class="line">            <span class="number">2513</span>             <span class="number">1903</span>             <span class="number">1809</span>             <span class="number">1715</span> </span><br><span class="line">          yogurt          (Other) </span><br><span class="line">            <span class="number">1372</span>            <span class="number">34055</span> </span><br><span class="line"></span><br><span class="line">element (itemset/transaction) length distribution:</span><br><span class="line">sizes</span><br><span class="line">   <span class="number">1</span>    <span class="number">2</span>    <span class="number">3</span>    <span class="number">4</span>    <span class="number">5</span>    <span class="number">6</span>    <span class="number">7</span>    <span class="number">8</span>    <span class="number">9</span>   <span class="number">10</span>   <span class="number">11</span>   <span class="number">12</span>   <span class="number">13</span>   <span class="number">14</span>   <span class="number">15</span>   <span class="number">16</span> </span><br><span class="line"><span class="number">2159</span> <span class="number">1643</span> <span class="number">1299</span> <span class="number">1005</span>  <span class="number">855</span>  <span class="number">645</span>  <span class="number">545</span>  <span class="number">438</span>  <span class="number">350</span>  <span class="number">246</span>  <span class="number">182</span>  <span class="number">117</span>   <span class="number">78</span>   <span class="number">77</span>   <span class="number">55</span>   <span class="number">46</span> </span><br><span class="line">  <span class="number">17</span>   <span class="number">18</span>   <span class="number">19</span>   <span class="number">20</span>   <span class="number">21</span>   <span class="number">22</span>   <span class="number">23</span>   <span class="number">24</span>   <span class="number">26</span>   <span class="number">27</span>   <span class="number">28</span>   <span class="number">29</span>   <span class="number">32</span> </span><br><span class="line">  <span class="number">29</span>   <span class="number">14</span>   <span class="number">14</span>    <span class="number">9</span>   <span class="number">11</span>    <span class="number">4</span>    <span class="number">6</span>    <span class="number">1</span>    <span class="number">1</span>    <span class="number">1</span>    <span class="number">1</span>    <span class="number">3</span>    <span class="number">1</span> </span><br><span class="line"></span><br><span class="line">   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. </span><br><span class="line">  <span class="number">1.000</span>   <span class="number">2.000</span>   <span class="number">3.000</span>   <span class="number">4.409</span>   <span class="number">6.000</span>  <span class="number">32.000</span> </span><br><span class="line"></span><br><span class="line">includes extended item information - examples:</span><br><span class="line">       labels  level2           level1</span><br><span class="line"><span class="number">1</span> frankfurter sausage meat and sausage</span><br><span class="line"><span class="number">2</span>     sausage sausage meat and sausage</span><br><span class="line"><span class="number">3</span>  liver loaf sausage meat and sausage</span><br></pre></td></tr></table></figure>
<p>通过itemFrequency()函数可以查看商品的交易比例。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; itemFrequency(Groceries[,<span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line">frankfurter     sausage  liver loaf </span><br><span class="line"><span class="number">0.058973055</span> <span class="number">0.093950178</span> <span class="number">0.005083884</span> </span><br></pre></td></tr></table></figure>
<p>通过以上数据我们可以得出以下结果：</p>
<ol>
<li>该数据集一共有9835行（交易记录），169列（所有交易的商品种类），因此矩阵中共有$9835\ast169=1662115$个位置，我们可以得出，在30天内共有$1662115\ast0.02609146=43367$件商品被购买，进一步可以得出在每次交易中包含了$43367/9835=4.409$件商品被购买；</li>
<li>most frequent items：列出了事务型数据中最常购买的商品。whole milk在9835次交易中被购买了2513次，因此我们可以得出结论：whole milk有$2513/9835=25.6\%$的概率出现在所有的交易中；</li>
<li>element (itemset/transaction) length distribution：呈现了一组关于交易规模的统计，总共有2159次交易中包含一件商品，有1次交易中包含了32件商品。我们可以看出，25%的交易中包含了两件或者更少的商品，大约一半的交易中商品数量不超过3件。</li>
</ol>
<p>为了直观地呈现统计数据，可以使用itemFrequenctyPlot()函数生成一个用于描绘所包含的特定商品的交易比例的柱状图。因为包含很多种商品，不可能同时展现出来，因此可以通过support或者topN参数进行排除一部分商品进行展示。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; itemFrequencyPlot(Groceries,support = <span class="number">0.1</span>)  <span class="comment"># support = 0.1 表示支持度至少为0.1</span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/FerretDoll/PictureWarehouse/master/img/apriori3.png" width="75%" height="75%"></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; itemFrequencyPlot(Groceries,topN = <span class="number">20</span>)  <span class="comment"># topN = 20 表示支持度排在前20的商品</span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/FerretDoll/PictureWarehouse/master/img/apriori4.png" width="75%" height="75%"></p>
<p>通过使用image()函数可以可视化整个稀疏矩阵。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; image(Groceries[<span class="number">1</span>:<span class="number">5</span>]) <span class="comment"># 生成一个5行169列的矩阵，矩阵中填充有黑色的单元表示在此次交易（行）中，该商品（列）被购买了</span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/FerretDoll/PictureWarehouse/master/img/apriori5.png" width="75%" height="75%"></p>
<p>从上图可以看出，第一行记录（交易）包含了四种商品（黑色的方块），这种可视化的图是用于数据探索的一种很有用的工具。它可能有助于识别潜在的数据问题，比如：由于列表示的是商品名称，如果列从上往下一直被填充表明这个商品在每一次交易中都被购买了；另一方面，图中的模式可能有助于揭示交易或者商品的有趣部分，特别是当数据以有趣的方式排序后，比如，如果交易按照日期进行排序，那么黑色方块图案可能会揭示人们购买商品的数量或者类型受季节性的影响。这种可视化对于超大型的交易数据集是没有意义的，因为单元太小会很难发现有趣的模式。</p>
<h3 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; grocery_rules &lt;- apriori(data=Groceries,parameter=list(support =,confidence =,minlen =))</span><br></pre></td></tr></table></figure>
<p>运行apriori()函数很简单，但是找到支持度和置信度参数来产生合理数量的关联规则时，可能需要进行大量的试验与误差评估。</p>
<p>如果参数设置过高，那么结果可能是没有规则或者规则过于普通而不是非常有用的规则；如果阈值太低，可能会导致规则数量很多，甚至需要运行很长的时间或者在学习阶段耗尽内存。</p>
<p>aprior()函数默认设置$support=0.1$和$confidence=0.8$。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; apriori(Groceries)</span><br><span class="line">set of <span class="number">0</span> rules</span><br></pre></td></tr></table></figure>
<p>因为$support=0.1$，则意味着该商品必须至少出现在$0.1 \ast 9835 = 983.5$次交易中，在前面的分析中，我们发现只有8种商品的$support&gt;=0.1$，因此使用默认的设置没有产生任何规则也不足为奇。</p>
<p>解决支持度设定问题的一种方法是：考虑一个有趣的模式之前，事先想好需要的最小交易数量，例如：我们可以认为如果一种商品一天被购买了2次，一个月也就是60次交易记录，这或许是我们所感兴趣的，据此，可以计算所需要的支持度$support=60/9835=0.006$;</p>
<p>关于置信度：设置太低，可能会被大量不可靠的规则淹没，设置过高，可能会出现很多显而易见的规则致使我们不能发现有趣的模式；一个合适的置信度水平的选取，取决于我们的分析目标，我们可以尝试以一个保守的值开始，如果发现没有具有可行性的规则，可以降低置信度以拓宽规则的搜索范围。</p>
<p>在此例中，我们将从置信度0.25开始，这意味着为了将规则包含在结果中，此时规则的正确率至少为25%，这将排除最不可靠的规则</p>
<p>$minlen=2$表示规则中至少包含两种商品，这可以防止仅仅是由于某种商品被频繁购买而创建的无用规则，比如在上面的分析中，我们发现whole milk出现的概率（支持度）为25.6%，很可能出现如下规则：$\{\}=&gt;whole milk$，这种规则是没有意义的。</p>
<p>最终，根据上面的分析我们确定如下参数设置：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; grocery_rules &lt;- apriori(data = Groceries,parameter = list(support = <span class="number">0.006</span>,confidence = <span class="number">0.25</span>,minlen = <span class="number">2</span>))</span><br><span class="line">&gt; grocery_rules</span><br><span class="line">set of <span class="number">463</span> rules</span><br></pre></td></tr></table></figure>
<h3 id="关联规则可视化"><a href="#关联规则可视化" class="headerlink" title="关联规则可视化"></a>关联规则可视化</h3><p>使用arulesViz包可对关联规则进行可视化。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">library</span>(arulesViz)</span><br></pre></td></tr></table></figure>
<p>通过plot()函数可以得到生成规则的散点图以及散点矩阵</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; plot(grocery_rules)</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/FerretDoll/PictureWarehouse/master/img/apriori6.png" width="75%" height="75%"></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; plot(grocery_rules@quality)</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/FerretDoll/PictureWarehouse/master/img/apriori7.png" width="75%" height="75%"></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; highLiftRules &lt;- head(sort(grocery_rules, by = <span class="string">&quot;lift&quot;</span>), <span class="number">5</span>)</span><br><span class="line">&gt; plot(highLiftRules, method = <span class="string">&quot;graph&quot;</span>, control = list(type = <span class="string">&quot;items&quot;</span>))</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/FerretDoll/PictureWarehouse/master/img/apriori8.png" width="75%" height="75%"></p>
<p>圆圈的大小表示支持度的大小，不同的项目通过有向箭头指向同一个支持度，表示相应项目组成的一个项集。</p>
<h3 id="评估模型的性能"><a href="#评估模型的性能" class="headerlink" title="评估模型的性能"></a>评估模型的性能</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; summary(grocery_rules)</span><br><span class="line">set of <span class="number">463</span> rules</span><br><span class="line"></span><br><span class="line">rule length distribution (lhs + rhs):sizes  <span class="comment"># 前件+后件的规则长度分布</span></span><br><span class="line">  <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span> </span><br><span class="line"><span class="number">150</span> <span class="number">297</span>  <span class="number">16</span>  <span class="comment">#有150个规则只包含2种商品，297个规则包含3种商品，16个规则包含4种商品</span></span><br><span class="line"></span><br><span class="line">   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. </span><br><span class="line">  <span class="number">2.000</span>   <span class="number">2.000</span>   <span class="number">3.000</span>   <span class="number">2.711</span>   <span class="number">3.000</span>   <span class="number">4.000</span> </span><br><span class="line"></span><br><span class="line">summary of quality measures:</span><br><span class="line">    support           confidence        coverage             lift       </span><br><span class="line"> Min.   :<span class="number">0.006101</span>   Min.   :<span class="number">0.2500</span>   Min.   :<span class="number">0.009964</span>   Min.   :<span class="number">0.9932</span>  </span><br><span class="line"> 1st Qu.:<span class="number">0.007117</span>   1st Qu.:<span class="number">0.2971</span>   1st Qu.:<span class="number">0.018709</span>   1st Qu.:<span class="number">1.6229</span>  </span><br><span class="line"> Median :<span class="number">0.008744</span>   Median :<span class="number">0.3554</span>   Median :<span class="number">0.024809</span>   Median :<span class="number">1.9332</span>  </span><br><span class="line"> Mean   :<span class="number">0.011539</span>   Mean   :<span class="number">0.3786</span>   Mean   :<span class="number">0.032608</span>   Mean   :<span class="number">2.0351</span>  </span><br><span class="line"> 3rd Qu.:<span class="number">0.012303</span>   3rd Qu.:<span class="number">0.4495</span>   3rd Qu.:<span class="number">0.035892</span>   3rd Qu.:<span class="number">2.3565</span>  </span><br><span class="line"> Max.   :<span class="number">0.074835</span>   Max.   :<span class="number">0.6600</span>   Max.   :<span class="number">0.255516</span>   Max.   :<span class="number">3.9565</span>  </span><br><span class="line">     count      </span><br><span class="line"> Min.   : <span class="number">60.0</span>  </span><br><span class="line"> 1st Qu.: <span class="number">70.0</span>  </span><br><span class="line"> Median : <span class="number">86.0</span>  </span><br><span class="line"> Mean   :<span class="number">113.5</span>  </span><br><span class="line"> 3rd Qu.:<span class="number">121.0</span>  </span><br><span class="line"> Max.   :<span class="number">736.0</span>  </span><br><span class="line"></span><br><span class="line">mining info:</span><br><span class="line">      data ntransactions support confidence</span><br><span class="line"> Groceries          <span class="number">9835</span>   <span class="number">0.006</span>       <span class="number">0.25</span></span><br><span class="line"> </span><br><span class="line">&gt; inspect(grocery_rules[<span class="number">1</span>:<span class="number">5</span>])</span><br><span class="line">     lhs             rhs                support     confidence coverage   lift    </span><br><span class="line">[<span class="number">1</span>] &#123;pot plants&#125; =&gt; &#123;whole milk&#125;       <span class="number">0.006914082</span> <span class="number">0.4000000</span>  <span class="number">0.01728521</span> <span class="number">1.565460</span></span><br><span class="line">[<span class="number">2</span>] &#123;pasta&#125;      =&gt; &#123;whole milk&#125;       <span class="number">0.006100661</span> <span class="number">0.4054054</span>  <span class="number">0.01504830</span> <span class="number">1.586614</span></span><br><span class="line">[<span class="number">3</span>] &#123;herbs&#125;      =&gt; &#123;root vegetables&#125;  <span class="number">0.007015760</span> <span class="number">0.4312500</span>  <span class="number">0.01626843</span> <span class="number">3.956477</span></span><br><span class="line">[<span class="number">4</span>] &#123;herbs&#125;      =&gt; &#123;other vegetables&#125; <span class="number">0.007727504</span> <span class="number">0.4750000</span>  <span class="number">0.01626843</span> <span class="number">2.454874</span></span><br><span class="line">[<span class="number">5</span>] &#123;herbs&#125;      =&gt; &#123;whole milk&#125;       <span class="number">0.007727504</span> <span class="number">0.4750000</span>  <span class="number">0.01626843</span> <span class="number">1.858983</span></span><br><span class="line">    count</span><br><span class="line">[<span class="number">1</span>] <span class="number">68</span>   </span><br><span class="line">[<span class="number">2</span>] <span class="number">60</span>   </span><br><span class="line">[<span class="number">3</span>] <span class="number">69</span>   </span><br><span class="line">[<span class="number">4</span>] <span class="number">76</span>   </span><br><span class="line">[<span class="number">5</span>] <span class="number">76</span>   </span><br></pre></td></tr></table></figure>
<p>这里需要解释一下<strong>lift（提升度）</strong>，表示用来度量一类商品相对于它的一般购买率，此时被购买的可能性有多大。通俗的讲就是：比如第一条规则$\{pot plants\}=&gt;\{whole milk\}$，$lift=1.565$，表明购买pot plants之后再购买whole milk商品的可能性是没有购买pot plants但是购买了whole milk的可能性的1.565倍；</p>
<p>第一条规则解读：如果一个顾客购买了pot plants，那么他还会购买whole milk，支持度support为0.0070，置信度confidence为0.4000，我们可以确定该规则涵盖了大约0.7%的交易，而且在购买了pot plants后，他购买whole milk的概率为40%，提升度lift值为1.565，表明他相对于一般没有购买pot plant商品的顾客购买whole milk商品的概率提升了1.565倍，我们在上面的分析中知道，有25.6%的顾客购买了whole milk，因此计算提升度为$0.40/0.256=1.56$，这与显示的结果是一致的，注意：标有support的列表示规则的支持度，而不是前件（lhs）或者后件（rhs）的支持度。</p>
<p>提升度$lift(X→Y)=\frac{P(Y|X)}{P(Y)}$，$lift(X→Y)$与$lift(Y→X)$是相同的。</p>
<p>如果$lift&gt;1$，说明这两类商品在一起购买比只有一类商品被购买更常见。一个大的提升度值是一个重要的指标，它表明一个规则是很重要的，并反映了商品之间的真实联系。</p>
<h3 id="提高模型的性能"><a href="#提高模型的性能" class="headerlink" title="提高模型的性能"></a>提高模型的性能</h3><p>对关联规则集合排序：根据购物篮分析的目标，最有用的规则或许是那些具有高支持度、信度和提升度的规则。arules包中包含一个sort()函数，通过指定参数by为”support”,”confidence”或者”lift”对规则列表进行重新排序。在默认的情况下，排序是降序排列，可以指定参数decreasing=FALSE反转排序方式。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; inspect(sort(grocery_rules,by=<span class="string">&quot;lift&quot;</span>)[<span class="number">1</span>:<span class="number">10</span>])</span><br><span class="line">    lhs                                             rhs                  support     confidence lift   </span><br><span class="line"><span class="number">3</span>   &#123;herbs&#125;                                      =&gt; &#123;root vegetables&#125;    <span class="number">0.007015760</span> <span class="number">0.4312500</span>  <span class="number">3.956477</span></span><br><span class="line"><span class="number">57</span>  &#123;berries&#125;                                    =&gt; &#123;whipped/sour cream&#125; <span class="number">0.009049314</span> <span class="number">0.2721713</span>  <span class="number">3.796886</span></span><br><span class="line"><span class="number">450</span> &#123;tropical fruit,other vegetables,whole milk&#125; =&gt; &#123;root vegetables&#125;    <span class="number">0.007015760</span> <span class="number">0.4107143</span>  <span class="number">3.768074</span></span><br><span class="line"><span class="number">174</span> &#123;beef,other vegetables&#125;                      =&gt; &#123;root vegetables&#125;    <span class="number">0.007930859</span> <span class="number">0.4020619</span>  <span class="number">3.688692</span></span><br><span class="line"><span class="number">285</span> &#123;tropical fruit,other vegetables&#125;            =&gt; &#123;pip fruit&#125;          <span class="number">0.009456024</span> <span class="number">0.2634561</span>  <span class="number">3.482649</span></span><br><span class="line"><span class="number">176</span> &#123;beef,whole milk&#125;                            =&gt; &#123;root vegetables&#125;    <span class="number">0.008032537</span> <span class="number">0.3779904</span>  <span class="number">3.467851</span></span><br><span class="line"><span class="number">284</span> &#123;pip fruit,other vegetables&#125;                 =&gt; &#123;tropical fruit&#125;     <span class="number">0.009456024</span> <span class="number">0.3618677</span>  <span class="number">3.448613</span></span><br><span class="line"><span class="number">282</span> &#123;pip fruit,yogurt&#125;                           =&gt; &#123;tropical fruit&#125;     <span class="number">0.006405694</span> <span class="number">0.3559322</span>  <span class="number">3.392048</span></span><br><span class="line"><span class="number">319</span> &#123;citrus fruit,other vegetables&#125;              =&gt; &#123;root vegetables&#125;    <span class="number">0.010371124</span> <span class="number">0.3591549</span>  <span class="number">3.295045</span></span><br><span class="line"><span class="number">455</span> &#123;other vegetables,whole milk,yogurt&#125;         =&gt; &#123;tropical fruit&#125;     <span class="number">0.007625826</span> <span class="number">0.3424658</span>  <span class="number">3.263712</span></span><br></pre></td></tr></table></figure>
<p>提取关联规则的子集：可以通过subset()函数提取我们感兴趣的规则。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; fruit_rules &lt;- subset(grocery_rules,items %<span class="keyword">in</span>% <span class="string">&quot;pip fruit&quot;</span>)  <span class="comment"># items 表明与出现在规则的任何位置的项进行匹配，为了将子集限制到匹配只发生在左侧或者右侧位置上，可以使用lhs或者rhs代替</span></span><br><span class="line">&gt; fruit_rules</span><br><span class="line">set of <span class="number">21</span> rules</span><br><span class="line">&gt; inspect(fruit_rules[<span class="number">1</span>:<span class="number">5</span>])</span><br><span class="line">    lhs                           rhs                support     confidence lift   </span><br><span class="line"><span class="number">127</span> &#123;pip fruit&#125;                =&gt; &#123;tropical fruit&#125;   <span class="number">0.020437214</span> <span class="number">0.2701613</span>  <span class="number">2.574648</span></span><br><span class="line"><span class="number">128</span> &#123;pip fruit&#125;                =&gt; &#123;other vegetables&#125; <span class="number">0.026131164</span> <span class="number">0.3454301</span>  <span class="number">1.785237</span></span><br><span class="line"><span class="number">129</span> &#123;pip fruit&#125;                =&gt; &#123;whole milk&#125;       <span class="number">0.030096594</span> <span class="number">0.3978495</span>  <span class="number">1.557043</span></span><br><span class="line"><span class="number">281</span> &#123;tropical fruit,pip fruit&#125; =&gt; &#123;yogurt&#125;           <span class="number">0.006405694</span> <span class="number">0.3134328</span>  <span class="number">2.246802</span></span><br><span class="line"><span class="number">282</span> &#123;pip fruit,yogurt&#125;         =&gt; &#123;tropical fruit&#125;   <span class="number">0.006405694</span> <span class="number">0.3559322</span>  <span class="number">3.392048</span></span><br></pre></td></tr></table></figure>
<h3 id="Apriori算法的缺点与改进"><a href="#Apriori算法的缺点与改进" class="headerlink" title="Apriori算法的缺点与改进"></a>Apriori算法的缺点与改进</h3><p>从以上的算法执行过程可以看到Apriori算法的缺点:</p>
<ol>
<li>在每一步产生侯选项集时循环产生的组合过多，没有排除不应该参与组合的元素(空间、时间)；</li>
<li>每次计算项集的支持度时，都对数据库中的全部记录进行了一遍扫描比较，如果是一个大型的数据库的话，这种扫描比较会大大增加计算机系统的I/O开销。而这种代价是随着数据库的记录的增加呈现出几何级数的增加(时间)。</li>
</ol>
<p>主要考虑从三个方面优化：</p>
<ol>
<li>数据库的压缩，如果一个条目（或者说项目）不包含任何一个k项集，那么它不可能包含任何一个k+1项集，即在下一次的遍历数据库时，不需要再去对该条目进行检查（通常做法是删除该条目，或者将这个条目做上标记）。</li>
<li>缩小候选项集的个数，即动态项集计数。在某个条目的统计之后，如果发现某个候选项集的计数已经满足了最小支持度，那么可以将这个项集直接放入到频繁项集中，这样以后就不用对该项集进行计数了</li>
<li>在连接的步骤之前，先利用之前提到的Apriori算法的第三个性质对项集进行筛选，提前删除不满足的项集。对k-1项项集中的每一个元素进行计数，若某个元素的个数小于k-1，则将k-1项集中包含该元素的项集删除。这样可以极大的减小了可能产生的候选项集的数量。</li>
</ol>
]]></content>
      <categories>
        <category>大数据分析</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
